<!DOCTYPE html>
<html>
<head>
<title>Fractals</title>
<style>
@media(prefers-color-scheme: dark){
  body{
    background-color: black;
    filter:invert(0.9);
  }
}
body,.part,#boxui{
  margin:0px;
}
#maindiv{
  width:700px;
  display:inline-block;
}
#config{
  display:inline-block;
  vertical-align:top;
}
@media (min-width : 800px){
  #sidediv{
    /*display:inline-block;*/
    position:absolute;
    top:0px;
    vertical-align:top;
    writing-mode: vertical-lr;
    text-orientation: upright;
    max-height: 700px;
    left:700px;
  }
}
#sidediv canvas{
  display:inline-block;
  
}
#bigPic{
}
.part{
  width:500px;height:500px;
  background:#0002;
  transform-origin:top left;
}
.part,#boxui{
  touch-action: none;
  position:absolute;
  top:0;left:0;
}
svg{
  pointer-events: none;
}
svg circle{
  pointer-events: all;
  fill:#40a040;
  r:5px;
  touch-action: none;
}
</style>
<script>
"use strict";
let parts = [
  {
    x:1/4, y:1/4, w:1/2,h:1/2,rot:15
  },
  {
    x:1/4, y:3/4, w:1/2,h:1/2,rot:0
  },
  {
    x:3/4, y:3/4, w:1/2,h:1/2,rot:0
  },
  {
    x:1/2, y:1/2, w:1/2,h:1/2,rot:0
  }
  /*{
    x:2/4, y:2/4, w:1,h:1,rot:0
  }*/
]
let wholePart = {x:1/2,y:1/2,w:1,h:1,rot:0}
let h=500
let w=500
let ox=100
let oy=100
let idmat = new DOMMatrix() 
let spmat = new DOMMatrix().translate(-ox-w/2,-oy-h/2) // convert from canvas coordinates to logical ones (500x500)
function partToMatrix(p){
  // return new DOMMatrix().translate(-ox-w/2,-oy-h/2) .translate(ox+(p.x-p.w/2)*h,oy+(p.y-p.h/2)*w).scale(p.w,p.h).rotate(p.rot).translate(ox+w/2,oy+h/2)
  //
  let m = spmat.inverse().translate((p.x-1/2)*h,(p.y-1/2)*w).rotate(p.rot).scale(p.w,p.h).multiply(spmat)
  //.translate(-ox-w/2,-oy-h/2)
  //  return new DOMMatrix().translate((p.x-p.w/2)*h,(p.y-p.h/2)*w).scale(p.w,p.h).rotate(p.rot)
  return m
}

</script>
</head>
<body>
<div id="maindiv">
<canvas id="bigPic" width=700 height=700>
</canvas>
<div style="margin-left:8px">
<form name="buttons">
<div id="sidediv">
a<br>
b<br>
c<br>
d<br>
</div>
<button onclick="saveImage()">Save Fractal</button><br>
<fieldset>
  <legend>Control configuration</legend>
<input type="checkbox" id="snap" name="snap" checked="true"><label for="snap">snap positons/widths</label><br>
<input type="checkbox" id="match" name="match" checked="true"><label for="match">match width and height (make/keep parts square when adjusted) </label><br>
<input type="checkbox" id="center" name="center" checked="true"><label for="center">resize around center </label>
</fieldset>
<!-- TODO:  -->
<!--<fieldset>
  
  <input type="radio" >
</fieldset>-->
</form>
<h2>Controls:</h2>
<ul>
  <li>Mouse: Select, move, resize and rotate part</li>
  <li>Tab or N: Cycle through parts</li>
  <li>Arrow Keys or wasd: Move selected part</li>
  <li>q/e: Rotate selected left/right</li>
  <li>Space: redraw with detail</li>
</ul>
</div>
</div>
<div id="config">
</div>
<div id=partsdiv style="position:absolute;top:0;left:0;">
</div>
<svg id="boxui" width="700" height="700" viewBox="0 0 700 700">
  <circle cx="100" cy="100" r="20" fill="red"></circ>
</svg>
<script>
"use strict";
let ctx = bigPic.getContext("2d")
//ctx.fillRect(1,1,20,20)
ctx.strokeRect(ox,oy,w,h)

// let p = {x:ox+w/2,y:oy+h/2}
//let ptsz=2
function drawFractal(n,count){
  bigPic.width|=0
  let mats = parts.map(partToMatrix)
  let ptsz = Math.sqrt(w*h/n)
  //ptsz*ptsz*n=w*h
  let p = {x:ox+w/2,y:oy+h/2}
  let containers
  if(count){
    containers = []
    for(let i=0;i<=Math.min(8,Math.log2(n));i++){
      let l=[]
      for(let x=0;x<(1<<i);x++)
        l.push(new Array(1<<i).fill(0))
      containers.push(l)
    }
  }
  let rtn = Math.sqrt(n)
  let mx=-Infinity
  let my=-Infinity
  let nx=Infinity
  let ny=Infinity
  let mxs = {x:-Infinity,y:-Infinity}
  let mns = {x:Infinity,y:Infinity}
  for(let i=0;i<100;i++){
    p = mats[(Math.random()*mats.length)|0].transformPoint(p)
  }
  for(let i=0;i<rtn;i++){
    p = mats[(Math.random()*mats.length)|0].transformPoint(p)
    for(let c of "xy"){
      if(mxs[c]<p[c])mxs[c]=p[c]
      if(mns[c]>p[c])mns[c]=p[c]
    }
  }
  for(let i=0;i<n;i++){
    p = mats[(Math.random()*mats.length)|0].transformPoint(p)
    ctx.fillRect(p.x-ptsz/2,p.y-ptsz/2,ptsz,ptsz)
    if(count){
      let x=p.x-ox
      let y=p.y-oy
      if(x>=0 && x<w && y>=0 && y<h){
        containers.map((c,i)=>c[((x<<i)/w)|0 ][((y<<i)/h)|0]+=1)
      }
    }
  }
  ctx.strokeRect(ox,oy,w,h)
  return containers
}

let f12 = new Array(13).fill(0).map((e,i)=>i/12)
let sqrts = new Array(13).fill(0).flatMap((e,i)=>{
  let rt = Math.sqrt(i)
  let a=[]
  for(let j=1; j/rt <1; j++){
    a.push(j/rt)
  }
  return a
})
let snapvalues=f12.concat(sqrts).sort()
snapvalues=snapvalues.reverse().map(x=>-x).concat(snapvalues)
for(let i=0;i+1<snapvalues.length;){
  if(snapvalues[i]==snapvalues[i+1])snapvalues.splice(i,1)
  else i++
}

function bsearch(a,v){
  let l=0
  let r=a.length
  while(r>l+1){
    let m=(l+r)>>1
    if(v<a[m])r=m
    else l=m
  }
  return
}

function drawPartdivs(parts){
  partsdiv.replaceChildren()
  for(let p of parts){
    let n = document.createElement("div")
    n.classList.add("part")
    n.style.transform=partToMatrix(p).translate(ox,oy) // First move it into the coordinate system the matrix is expecting
    n.addEventListener("pointerdown",e=>moveAction=selectAndMovePart(p,e))
    p.div=n
    partsdiv.append(n)

  }
}

function mksvgel(tag){
  return document.createElementNS("http://www.w3.org/2000/svg",tag)
}

// UI
let moveAction=()=>{}
function drawBox(part){
  let box = mksvgel("g")
  for (let dx of [-1,0,1])for (let dy of [-1,0,1]) {
    let c = mksvgel("circle")
    part[[dx,dy]]=c
    if(dx*dy==1) c.style.cursor="nwse-resize"
    else if(dx*dy==-1) c.style.cursor="nesw-resize"
    else if (!(dx||dy)) c.style.cursor="grab"
    else if (dx==0) c.style.cursor="ns-resize"
    else if (dy==0) c.style.cursor="ew-resize"
    c.addEventListener("pointerdown",()=>moveAction=chooseResize(dx,dy,part))
    box.append(c)
  }
  return box
}

function transformChanged(part,noRedrawFractal){
  let mat = partToMatrix(part)
  for (let dx of [-1,0,1])for (let dy of [-1,0,1]) {
    let c=part[[dx,dy]]
    if(c){
      if (!(dx||dy)) dy-=1.4
      let {x,y} = mat.transformPoint({x:ox+w*(1+dx)/2,y:oy+h*(1+dy)/2})
      c.setAttribute("cx",x)
      c.setAttribute("cy",y)
      c.setAttribute("r",5)
    }
  }
  part.div.style.transform = mat.translate(ox,oy)
  if(!noRedrawFractal) drawFractal(10000)
}
/*
function drawBoxes(){
  parts.map(part=>boxui.append(drawBox(part)))
}*/
let selected
function selectAndMovePart(p,e){
  selectPart(p)
  let initex=e.pageX
  let initey=e.pageY
  let original = {x:p.x,y:p.y}
  return (e)=>{
    p.x=original.x+(e.pageX-initex)/w
    p.y=original.y+(e.pageY-initey)/h
    transformChanged(p)
  }
}
function selectPart(p){
  if(selected!==p){
    selected=p
    boxui.replaceChildren(drawBox(p))
    transformChanged(p,true)
  }
}
function deselect(){
  selected=undefined
  boxui.replaceChildren()
}
let ot = bigPic.offsetTop // for adjusting the mouse 
let ol = bigPic.offsetLeft
function chooseResize(dx,dy,part){
  // set the moveAction while the mouse is held over handles dx,dy
  if(!(dx||dy)){
    let cx = part.x*w+ox+ol
    let cy = part.y*h+oy+ot
    return (e) => {
      part.rot = Math.atan2(e.pageX-cx,-e.pageY+cy)*180/Math.PI + 360
      if(true){//(cliprot){
        part.rot-=((part.rot+7.5)%15 -7.5)
        part.rot|=0
      }
      console.log(part.rot)
      transformChanged(part)
    }
  }
  let o = {w:part.w,h:part.h}
  //transform original into rotated coordinates
  let cmat = idmat.translate(1/2,1/2).rotate(-part.rot).translate(-1/2,-1/2)
  let cmati = cmat.inverse()
  let ro = cmat.transformPoint({x:part.x,y:part.y})

  // Transform m into unit-square (rotated) coordinates
  let unrot = idmat.scale(1/w,1/h).translate(w/2,h/2).rotate(-part.rot).translate(-w/2-ox,-h/2-oy).translate(-ol,-ot);
  return (e) => {
    let m = unrot.transformPoint({x:e.pageX,y:e.pageY})
    // ro.x-dx*o.w/2 = n.x-dx*n.w/2
    // n.x+dx*n.w/2 = m.x
    let nx=dx?(m.x+ro.x-dx*o.w/2)/2:ro.x
    let ny=dy?(m.y+ro.y-dy*o.h/2)/2:ro.y
    let {x,y}=cmati.transformPoint({x:nx,y:ny})
    part.x=x
    part.y=y // need to change both in case of rotation
    if(dx){
      part.w=(m.x-ro.x+dx*o.w/2)/dx
    }
    if(dy){
      part.h=(m.y-ro.y+dy*o.h/2)/dy
    }
    //spmat.inverse().translate((part.x-1/2)*h,(p.y-1/2)*w).rotate(part.rot).multiply(spmat);
    transformChanged(part);
  }
}

document.addEventListener("pointermove",(e)=> {moveAction(e)})
let conts
function pointerEnd(e){
  drawCarefully()
  moveAction = ()=>{}
}
function drawCarefully(){
  conts = drawFractal(100000,true)
  console.log(calcDim(conts))
}
document.addEventListener("pointerup",pointerEnd)
document.addEventListener("pointercancel",pointerEnd)

document.addEventListener("pointerdown",(e)=>
  console.log(e,e.x,e.y)
)
document.addEventListener("keydown",(e)=>{
    if(selected){
      console.log(e)
      let unhandled=false;
      switch(e.key){
        case "d":
        case "ArrowRight":
          selected.x+=1/60
          transformChanged(selected)
          break;
        case "a":
        case "ArrowLeft":
          selected.x-=1/60
          transformChanged(selected)
          break;
        case "s":
        case "ArrowDown":
          selected.y+=1/60
          transformChanged(selected)
          break;
        case "w":
        case "ArrowUp":
          selected.y-=1/60
          transformChanged(selected)
          break;
        case "q":
          selected.rot-=15
          transformChanged(selected)
          break;
        case "e":
          selected.rot+=15
          transformChanged(selected)
          break;
        case " ":
          drawCarefully()
          break;
        case "Tab":
        case "n":
          for(let i=0;i<parts.length;i++){
            if(selected==parts[i]) {
              selectPart(parts[(i+1)%parts.length])/*
              if(i+1<parts.length) selectPart(parts[i+1])
              else deselect()*/
              break;
            }
            if(i+1==parts.length)selectPart(parts[0])
          }
          break;
        default:
          unhandled=true
      }
      if(!unhandled && selected){
        e.preventDefault()
        // stops scrolling (arrow keys and space) and might do something about tab
      }
    }
  }
)

drawPartdivs(parts)
drawFractal(10000)

function logparts(){
  console.log("[" + parts.map(p=> "{"+["x","y","w","h","rot"].map(c=>c+":"+p[c]).join(",")+"}" ).join(",")+"]")
}
function calcDim(conts){
  return conts.map((c,i)=>{
    let ni = c.reduce(((a,r)=>a+r.reduce(((a,b)=>a+(b!=0)),0)),0)
    return Math.log2(ni)/i
  })

}
function copyparts(parts){
  return parts.map(p=>({"x":p.x,"y":p.y,"w":p.w,"h":p.h,"rot":p.rot}))
}
//Save/load
let saved = JSON.parse(localStorage.getItem("parts"))
if(saved===null) saved=[]
function saveImage(){
  let pts = copyparts(parts)
  saved.push(pts)
  localStorage.setItem("parts",JSON.stringify(saved))
  mkSideCanvas(pts)
}
function mkSideCanvas(pts){// assumes pts is never mutated
  let op=parts
  parts=pts
  drawCarefully()
  let newCanvas = document.createElement("canvas")
  newCanvas.width=100
  newCanvas.height=100
  sidediv.prepend(newCanvas)
  //newCanvas.parts = pts
  newCanvas.addEventListener("click",(e)=>{
    parts = copyparts(pts)
    resetParts()
  })
  let ctx=newCanvas.getContext("2d")
  ctx.drawImage(bigPic, ox, oy, w, h, 0, 0, newCanvas.width, newCanvas.height)
  parts = op
  return newCanvas
}
for(let im of saved){
  //parts=copyparts(im)
  mkSideCanvas(im)
}
function resetParts(){
  drawPartdivs(parts)
  selectPart(parts[0])
  drawFractal(100000)
}
resetParts()
// saveImage()
//drawBoxes()
/*
TODO: 
arrow keys
add snapping to rational square roots
*/
</script>
</body>
</html>
